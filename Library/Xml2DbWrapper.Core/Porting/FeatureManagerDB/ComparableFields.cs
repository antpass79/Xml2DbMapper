using System;
using System.Linq;
using System.Runtime.Serialization;
using Xml2DbMapper.Core.Porting.Contract.Enums;

//fg01122015

namespace Xml2DbMapper.Core.Porting.FeatureManagerDB
{

	/// parent class including all interesting fields in the database
	[DataContract(Namespace = "")]
	public abstract class ComparableFields : FeaturesFields
	{
		[DataMember(EmitDefaultValue = false, IsRequired = false)]
		public abstract Int32? LogicalModelId
		{
			get;
			set;
		}
		[DataMember(EmitDefaultValue = false, IsRequired = false)]
		public override abstract Int32? OptionId
		{
			get;
			set;
		}
		[DataMember(EmitDefaultValue = false, IsRequired = false)]
		public override abstract Int32? ApplicationId
		{
			get;
			set;
		}
		[DataMember(EmitDefaultValue = false, IsRequired = false)]
		public abstract UserLevel? UserLevel
		{
			get;
			set;
		}
		[DataMember(EmitDefaultValue = false, IsRequired = false)]
		public abstract Int32? Version
		{
			get;
			set;
		}
		[DataMember(EmitDefaultValue = false, IsRequired = false)]
		public override abstract Int32? ProbeId
		{
			get;
			set;
		}
		[DataMember(EmitDefaultValue = false, IsRequired = false)]
		public abstract ProbeType? TransducerType
		{
			get;
			set;
		}
		[DataMember(EmitDefaultValue = false, IsRequired = false)]
		public override abstract Int32? KitId
		{
			get;
			set;
		}
		[DataMember(EmitDefaultValue = false, IsRequired = false)]
		public abstract Int32? CountryId
		{
			get;
			set;
		}
		[DataMember(EmitDefaultValue = false, IsRequired = false)]
		public abstract Int32? DistributorId
		{
			get;
			set;
		}

		/// <summary>
		/// checks if two rules have a generic override: if all parameters specified for both inputs are equal the rules override.
		///
		/// *THIS CODE SHOULD BE AUTOMATICALLY GENERATED BY THE TEXT TEMPLATE*
		///
		/// </summary>
		public Boolean genericOverride(ComparableFields r2)
		{
			return (
					   (((this.LogicalModelId == r2.LogicalModelId) && (r2.LogicalModelId != null)) || (this.LogicalModelId == null) || (r2.LogicalModelId == null)) &&
					   (((this.ProbeId == r2.ProbeId) && (r2.ProbeId != null)) || (this.ProbeId == null) || (r2.ProbeId == null)) &&
					   (((this.TransducerType == r2.TransducerType) && (r2.TransducerType != null)) || (this.TransducerType == null) || (r2.TransducerType == null)) &&
					   (((this.ApplicationId == r2.ApplicationId) && (r2.ApplicationId != null)) || (this.ApplicationId == null) || (r2.ApplicationId == null)) &&
					   (((this.OptionId == r2.OptionId) && (r2.OptionId != null)) || (this.OptionId == null) || (r2.OptionId == null)) &&
					   (((this.UserLevel == r2.UserLevel) && (r2.UserLevel != null)) || (this.UserLevel == null) || (r2.UserLevel == null)) &&
					   (((this.KitId == r2.KitId) && (r2.KitId != null)) || (this.KitId == null) || (r2.KitId == null)) &&
					   (((this.CountryId == r2.CountryId) && (r2.CountryId != null)) || (this.CountryId == null) || (r2.CountryId == null)) &&
					   (((this.DistributorId == r2.DistributorId) && (r2.DistributorId != null)) || (this.DistributorId == null) || (r2.DistributorId == null)) &&
					   (((this.Version == r2.Version) && (r2.Version != null)) || (this.Version == null) || (r2.Version == null)));
		}


		/// For override checks
		public static Boolean isContainedFull(ComparableFields contained, ComparableFields container)
		{
			return isContained(contained, container) && isModelContained(contained, container);
		}


		public static Boolean isContained(ComparableFields contained, ComparableFields container)
		{
			return isContainedSlim(contained, container) && isBaseContained(contained, container);
		}

		//      // base conteined with inverted inputs
		//public static Boolean isAlwaysContained(ComparableFields contained, ComparableFields container)
		//{
		//  var c1 = contained;
		//  var c2 = container;
		//  return isContainedSlim(contained, container, isValueAlwaysContained) && isModelContained(contained, container, isValueAlwaysContained)
		//         && isBaseContained(c2, c1, isValueAlwaysContained, isRangeAlwaysContained);
		//}

		// compares only Model, option, probe and application
		public static Boolean IsContainedReduced(ComparableFields contained, ComparableFields container)
		{
			if (!isValueContained(contained.LogicalModelId, container.LogicalModelId))
			{
				return false;
			}
			if (!isValueContained(contained.OptionId, container.OptionId))
			{
				return false;
			}
			if (!isValueContained(contained.ApplicationId, container.ApplicationId))
			{
				return false;
			}
			if (!isValueContained(contained.ProbeId, container.ProbeId))
			{
				return false;
			}
			if (!isValueContained((Int32?)contained.UserLevel, (Int32?)container.UserLevel))
			{
				return false;
			}
			if (container.KitId != null)
			{
				return false;
			}
			if (container.TransducerType != null)
			{
				return false;
			}
			if (container.CountryId != null)
			{
				return false;
			}
			if (container.DistributorId != null)
			{
				return false;
			}
			if (container.Version != null)
			{
				return false;
			}
			return true;
		}


		// Checks all the interesting fields alfter being filtered with the base Containance (isBaseContained)
		public static Boolean isContainedSlim(ComparableFields contained, ComparableFields container)
		{
			return isContainedSlim(contained, container, isValueContained);
		}

		public static Boolean isContainedSlim(ComparableFields contained, ComparableFields container, Func<int?, int?, bool> IsValueContainedFunc)
		{
			if (!IsValueContainedFunc(contained.OptionId, container.OptionId))
			{
				return false;
			}
			if (!IsValueContainedFunc(contained.ApplicationId, container.ApplicationId))
			{
				return false;
			}
			if (!IsValueContainedFunc(contained.ProbeId, container.ProbeId))
			{
				return false;
			}
			if (!IsValueContainedFunc((Int32?)contained.TransducerType, (Int32?)container.TransducerType))
			{
				return false;
			}
			if (!IsValueContainedFunc(contained.KitId, container.KitId))
			{
				return false;
			}

			return true;
		}

		// checks only the fields automatically filled by the License Manager (The model is filtered by file loading)
		public static Boolean isBaseContained(ComparableFields contained, ComparableFields container)
		{
			return isBaseContained(contained, container, isValueContained, isRangeContained);
		}

		public static Boolean isBaseContained(ComparableFields contained, ComparableFields container, Func<int?, int?, bool> IsValueContainedFunc, Func<int?, int?,
											  bool> IsRangeContainedFunc)
		{
			if (!IsValueContainedFunc(contained.CountryId, container.CountryId))
			{
				return false;
			}
			if (!IsValueContainedFunc(contained.DistributorId, container.DistributorId))
			{
				return false;
			}
			if (!IsValueContainedFunc((Int32?)contained.UserLevel, (Int32?)container.UserLevel))
			{
				return false;
			}
			if (!IsRangeContainedFunc(contained.Version, container.Version))
			{
				return false;
			}
			return true;
		}


		// checks the Model only in order to filter the rules and group them by model in different files
		public static bool isModelContained(ComparableFields contained, ComparableFields container)
		{
			return isModelContained(contained, container, isValueContained);
		}
		public static bool isModelContained(ComparableFields contained, ComparableFields container, Func<int?, int?, bool> IsValueContainedFunc)
		{
			return IsValueContainedFunc(contained.LogicalModelId, container.LogicalModelId);
		}


		public static Boolean isValueContained(Int32? contained, Int32? container)
		{
			if (container == null)
			{
				return true;
			}
			if (contained == null)
			{
				return false;
			}
			return contained == container;
		}

		// This handles rules forbidding for values lower than specified (e.g. blocks old versions)
		public static Boolean isRangeContained(Int32? contained, Int32? container)
		{
			if (container == null)
			{
				return true;
			}
			if (contained == null)
			{
				return false;
			}
			return contained < container;
		}


		// used in WPF to retrieve all rules regarding the given input
		public static Boolean isValueAlwaysContained(Int32? contained, Int32? container)
		{
			if (container == null || contained == null)
			{
				return true;
			}
			return contained == container;
		}

		public static Boolean isRangeAlwaysContained(Int32? contained, Int32? container)
		{
			if (container == null || contained == null)
			{
				return true;
			}
			return contained < container;
		}

		public static Int32? GetNumericVersion(String stringVersion)
		{
			// converts from format 06.00.02 => 60002 (or e.g. 5.15 -> 51500 or e.g. 3 => 30000)
			if (!string.IsNullOrEmpty(stringVersion))
			{
				var numbers = stringVersion.Split('.');
				var result = Convert.ToInt32(numbers[0]) * 10000;
				if (numbers.Count() > 1)
				{
					result += Convert.ToInt32(numbers[1]) * 100;
				}
				if (numbers.Count() > 2)
				{
					result += Convert.ToInt32(numbers[2]);
				}

				return result;
			}
			else
			{
				return null;
			}
		}

		public static String GetStringVersion(int IntVersion)
		{
			// converts from format 60002 => 06.00.02
			if (IntVersion >= 10000)
			{
				var major = GetMajorFromNumericVersion(IntVersion);
				var middle = (IntVersion - major * 10000) / 100;
				var minor = IntVersion - middle * 100 - major * 10000;
				return BuildStringVersion(major, middle, minor);
			}
			else
			{
				return null;
			}
		}

		public static string BuildStringVersion(int? major, int? middle, int? minor)
		{
			return (major != null ? major.ToString().PadLeft(2, '0') : "") + "."
				   + (middle != null ? middle.ToString().PadLeft(2, '0') : "") + "."
				   + (minor != null ? minor.ToString().PadLeft(2, '0') : "");
		}

		public static int GetMajorFromNumericVersion(int IntVersion)
		{
			return IntVersion / 10000;
		}

		public static Int32 GetNumericVersionFromMajor(double MajorVersion)
		{
			// converts from format 7
			return (int)(MajorVersion * 10000);
		}

	}
}
